#!/usr/bin/env python3
"""Lightweight Python launcher for the `kclone` package.

This script mirrors the original bash wrapper but can be invoked with
`python ./kclone` as well as executed directly after `chmod +x`.
"""
import os
import sys
import runpy


def repo_root() -> str:
	return os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))


def main(argv: list[str]) -> int:
	root = repo_root()
	src_path = os.path.join(root, "python", "src")

	# Ensure local package path is first on sys.path and PYTHONPATH
	if src_path not in sys.path:
		sys.path.insert(0, src_path)
	os.environ["PYTHONPATH"] = src_path + os.pathsep + os.environ.get("PYTHONPATH", "")

	DEFAULT_DB = os.path.join(root, "python_cluster.db")

	args = list(argv)

	# If running the control-loop and no positional DB path is provided, append default DB
	if len(args) >= 1 and args[0] == "control-loop":
		if "--help" in args or "-h" in args:
			# let the module handle help flags
			pass
		else:
			# check for any positional argument after the command (doesn't start with '-')
			has_positional = any(not a.startswith("-") for a in args[1:])
			if not has_positional:
				args.append(DEFAULT_DB)

	# Set sys.argv for module execution and run the package as a module
	sys.argv = [sys.argv[0]] + args
	try:
		# Run package entrypoint (equivalent to `python -m kclone`)
		runpy.run_module("kclone", run_name="__main__")
		return 0
	except SystemExit as e:
		# Propagate normal exits
		code = e.code if isinstance(e.code, int) else 0
		return code
	except Exception as e:  # pragma: no cover - surface errors to user
		print(f"Error running kclone: {e}", file=sys.stderr)
		return 1


if __name__ == "__main__":
	raise SystemExit(main(sys.argv[1:]))
